/*
Exceptions::
~ Runtime error
~ represents Errornous situation
~ Wrapped in an object

=> Ways to deal / handle exceptions:
1. Ignore it    -> improper termination, not meaningful
2. Handle it where it is occuerd.
3. Handle it somewhere else (on another location).


=> Keywords to handle exceptions:
* try
* catch
* finally
* throws
* throw

Try-Catch Exception Handling ::
* try, catch block handles exception where it is occured.
* One try block must have atleast one adjacent catch block.
But can also have more than one catch block. (multiple catch blocks)

try {
    // JAVA Code which can generate exception (div, [], file, DB, Socket, .....)


} exception (<Exception type object>)      // Exception type (object) : means which type of exception will be handled here.
{
    // error handling code
}


=> LIKE::
try {
    // JAVA Code
    // [] -> Index Out of Bound Exception

} catch (ArithmeticException ex)    // To handle Arithmetic Exception (div by zero)
{

} catch (IndexOutOfBoundException ex)   // To handle Index Out of Bound Exception (access index that not exists)
{

    // Control Comes here, and then by skipping all below catch blocks, it go outside.

} catch (NumberFormatException ex)      // To handle Exception generated by wrong conversion of data / number
{

} catch (IO Exception ex)   // To handle invalid reading / writing of file
{

}


* In Multiple catch blocks, If one catch block is execute due to some macthed-exception (which is matched by that catch block) then all the below catch blocks will be skipped / bypass. Control will be come outside of try-catch block.



=> If we do not want to handle all the exceptions separately in separate catch blocks, we can just write one catch block which is taking exception type of class 'Exception ex'. Then all the exceptions will be caught / handle there inside it.

try {
    // JAVA Code
    // [] -> Index Out of Bound Exception

} catch (Exception ex)  // It will handle all types of Exceptions because it is parent class of all the exception classes.
{

} catch (ArithmeticException ex)    // To handle Arithmetic Exception (div by zero)
{

} catch (IndexOutOfBoundException ex)   // To handle Index Out of Bound Exception (access index that not exists)
{

}
// All the catch blocks below ' Exception ex' type exception catch block will never execute bcz all exceptions will / can be handle in 'Exception ex' catch block and will skipp all below catch blocks always. Thus, JAVA will give us error at time of compilation of this code. Because our code contain some unreachable part/code which will never be executed. 

-> So, to avoid above compile time error, best approach is:


try {
    // JAVA Code
    // [] -> Index Out of Bound Exception

} catch (ArithmeticException ex)    // To handle Arithmetic Exception (div by zero)
{

} catch (IndexOutOfBoundException ex)   // To handle Index Out of Bound Exception (access index that not exists)
{
    
} catch (Exception ex)  // It will handle all types of Exceptions because it is parent class of all the exception classes.
{

} 

* Writing Exception ex at the end, So, it will only execute hen no ther macthes above.


// Or 1 more method to avoid compile time error.

try {
    // JAVA Code
    // [] -> Index Out of Bound Exception

} catch (Exception ex)  // It will handle all types of Exceptions because it is parent class of all the exception classes.
{

} 

* Simply write 1 catch block which has Exception ex type. This cann handle all types of exception, But here we have a problem that we cannot figure out which type of exception comes, because it will always go in 1 same catch block. But we can display JAVA base built in messages (like java.lang.ArithemeticException -> which is not a userfriendly message at all) for that exceptions by using some methods of object like:: (Here 'ex' is object variable.)

-> ex.toString();               // This function displays info about object.
-> ex.printStackTrace();
-> ex.getMessage();

* By default when we print object it will simply call its toString function of that class. (As we do not write this toString function by ourself. So, we got this function which is written in java.lang.Object class.)
to String() -> java.lang.Object

* One try block can have many exceptions but because of one exception it go to matched catch block and never return to that same try block again...

To make robust application::
If user makes mistakes, our system handles it, then in form of that if user enter wrong input then by applying if-else check or while do loop we can take input again and again till he inputs correct input.
*/

public class Exception_Handling_Try_Catch {
    public static void main(String args[]) {
        try {
            int array[] = new int[50];      
            array[40] = 10;                 // Array Index Out of Bounds Exception
            int div = array[50] / 0;

        } catch(ArrayIndexOutOfBoundsException ex) 
        {
            System.out.println("Exception : Array Index Out of Bound");

        }  catch(ArithmeticException ex) 
        {
            System.out.println("Exception : Arithmetic Exception");

        } catch(Exception ex) 
        {
            System.out.println("Parent Exception");

        } // } catch(ArithmeticException ex)          // ERROR!!!!!!
        // {
        //         System.out.println("Exception : Array Index Out of Bound");

        // }

    }
}
